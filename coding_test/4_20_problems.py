# -*- coding: utf-8 -*-
"""4/20/problems.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oiLx8rGYNcY_GE5ne3l1O7jJOOvYAQvX
"""

#땅따먹기

from copy import deepcopy
def solution(land):
    dp = deepcopy(land[0])
    new_dp = deepcopy(land[0])
    for i in range(1,len(land)):
        for j in range(4):
            max_number = 0
            for k in range(4):
                if j==k:
                    continue
                max_number = max(max_number,dp[k])
            new_dp[j]=max_number+land[i][j]
        dp = deepcopy(new_dp)
    return max(dp)

# 게임 맵 최단 거리

from collections import deque
def solution(maps):
    n = len(maps)
    m = len(maps[0])
    answer = 1
    q = deque()
    q.append((0,0,answer))
    maps[0][0]=answer
    dx = [0,1,0,-1]
    dy = [-1,0,1,0]
    
    while q:
        row_now,col_now,answer = q.popleft()
        for i in range(4):
            ny = row_now + dy[i]
            nx = col_now + dx[i]
            if 0<=nx<m and 0<=ny<n and maps[ny][nx]==1:
                q.append((ny,nx,answer+1))
                maps[ny][nx]=answer+1
    if maps[-1][-1] ==1:
        return -1
    return maps[-1][-1]

# 배달
# 1번마을에 있는 음식점에서 각 마을로
# K시간 이하로 배달이 가능한 마을에서만 주문을 받음
# 주문을 받을 수 있는 마을의 개수
# dijkstra algorithm
import heapq
def solution(N, road, K):
    answer = 0
    graph =[[] for _ in range(N+1)]
    for i in road:
        a,b,c = i
        graph[a].append((b,c))
        graph[b].append((a,c))
    INF  = int(1e7)
    dist = [INF]*(N+1)
    dist[1]=0
    q = []
    q.append((0,1))
    while q:
        cost,now = heapq.heappop(q)
        if cost>dist[now]:
            continue
        for j in graph[now]:
            if dist[j[0]]>=cost+j[1]:
                heapq.heappush(q,(cost+j[1],j[0]))
                dist[j[0]]=cost+j[1]
    for i in dist:
        if i <=K:
            answer+=1
    return answer

# 영어 끝말잇기
# 2<=n <=10
def solution(n, words):
    result = [words[0]]
    for word in words[1:]:
        if word in result:
            break
        else:
            if word[0]!=result[-1][-1]:
                break
            result.append(word)   
    if len(result)==len(words):
        return [0,0]
    N = len(result)+1
    q = N//n
    r = N%n
    if r == 0:
        r = n
    else:
        q +=1
    return [r,q]

# 점프와 순간 이동
# K만큼 점프하면 K만큼 건전지 사용량
# 현재까지 온거리x2에 해당하는 위치 순간이동
def solution(n):
    answer= 0
    while n>=1:
        if n%2==0:
            n=n//2
        else:
            n-=1
            answer+=1
    return answer

# 방문길이
# (0,0)에서 시작

def solution(dirs):
    graph = [[0]*11 for _ in range(11)]
    row_now,col_now = 5,5
    result = []
    direction = ['U','R','D','L']
    dx = [0,1,0,-1]
    dy = [-1,0,1,0]
    answer = 0
    for dir in dirs:
        for i in range(4):
            if dir == direction[i]:
                nx = col_now + dx[i]
                ny = row_now + dy[i]
        if 0<=nx<11 and 0<=ny<11:
            if (row_now,col_now,ny,nx) not in result and (ny,nx,row_now,col_now) not in result:
                result.append((row_now,col_now,ny,nx))
                answer+=1
            row_now,col_now = ny,nx
    return answer



# 예상대진표
def solution(n,a,b):
    #항상 a가 더 작다는 가정
    answer=1
    if a > b:
        a,b = b,a
    while b-a>1:
        if a%2==1:
            a+=1
        a=a/2
        if b%2==1:
            b+=1
        b=b/2
        answer+=1
    while a%2==0:
        answer+=1
        a=a/2
    return answer