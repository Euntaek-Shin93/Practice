# -*- coding: utf-8 -*-
"""4/18/problems.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vpg2K6KPYemQIZ0nOiCkbQxnGkAsmhqC
"""

#멀리뛰기
#dp
#배열의 크기 때문에 변수로 놓는게 나을수 있음
def solution(n):
    prev_x = 2
    prev_prev_x=1
    if n==1:
        return prev_prev_x
    if n==2:
        return prev_x
    for i in range(2,n):
        x = (prev_x+prev_prev_x)%1234567
        prev_prev_x = prev_x
        prev_x = x
        
    answer = x
    return answer

#야근지수
#works에서 n시간동안 최대한 숫자를 공평하게 나눠서 빼야한다.
#맨끝에서부터 그앞에 값이랑 같게 빼면서 index를 찾아나가
#처음에 틀렸던 건 for문안에 sub을 넣어서 works[0]값이 바뀐상태로 나머지가 빼져서 틀림
def solution(n, works):
    if sum(works)<=n:
        return 0
    works.sort(reverse=True)
    while n>0:
        idx = find_idx(works)
        if idx == len(works)-1:
            q = n//(idx+1)
            r = n%(idx+1)
            for i in range(idx+1):
                works[i]-=q
            for i in range(r):
                works[i]-=1
            break
        else:
            if n <= (works[idx]-works[idx+1]) * (idx+1):
                q = n//(idx+1)
                r = n%(idx+1)
                for i in range(idx+1):
                    works[i]-=q
                for i in range(r):
                    works[i]-=1
                break
            else:
                sub=works[0]-works[idx+1]
                for i in range(idx+1):
                    works[i]-=sub
                n-= sub*(idx+1)
    answer = 0
    for i in range(len(works)):
        answer+=works[i]**2
    return answer
def find_idx(arr):
    idx = 0
    for i in range(len(arr)):
        if arr[0]>arr[i]:
            idx = i-1
            return idx
    else: idx = len(arr)-1
    return idx

# 줄 서는 방법
#[1,2,3]
#[1,2,3,4]에 대한 case만 분석하면 된다.
#arr.sort()는 none type list +=arr.sort()는 안됨 
import math
def solution(n, k):
    arr = [i+1 for i in range(n)]
    answer = []
    k = k-1
    while n>=3:
        N = math.factorial(n-1)
        q = k//N
        r = k%N
        answer.append(arr[q])
        arr.remove(arr[q])
        k = r
        n-=1
    if k==1:
        arr.sort(reverse=True)
        answer+=arr
    if k==0:
        answer+=arr
    return answer

# 하노이의 탑
#그전까지 했던 방법을 2,3번을 모두 바꾸고
#추가된 맨 밑에 있는 원판을 3번으로 옮기면
# 그전의 방법을 다시 하면 되는데 1,2번을 바꿔서 하면 됨
from copy import deepcopy
def solution(n):
    answer = [[1,2], [1,3], [2,3] ]
    if n ==1:
        return [[1,3]]
    if n ==2:
        return [ [1,2], [1,3], [2,3] ]
    for i in range(3,n+1):
        prev = deepcopy(answer)
        answer = []
        for j in prev:
            if j == [2,3]:
                answer.append([3,2])
            elif j ==[3,2]:
                answer.append([2,3])
            elif j ==[1,3]:
                answer.append([1,2])
            elif j == [1,2]:
                answer.append([1,3])
            elif j == [3,1]:
                answer.append([2,1])
            elif j == [2,1]:
                answer.append([3,1])
        answer.append([1,3])
        for j in prev:
            if j == [1,2]:
                answer.append([2,1])
            elif j == [1,3]:
                answer.append([2,3])
            elif j == [2,3]:
                answer.append([1,3])
            elif j ==[3,1]:
                answer.append([3,2])
            elif j ==[3,2]:
                answer.append([3,1])
            elif j ==[2,1]:
                answer.append([1,2])
            elif j ==[2,3]:
                answer.append([1,3])
        
    return answer

# 숫자 게임
# 배열B를 sort
# A도 sort
# A보다 큰 값을 찾는 함수를 만들어서 index를 찾고,
# 그 다음 값을 찾을 때는, index+1부터 진행
def solution(A, B):
    A.sort()
    B.sort()
    idx = 0
    answer = 0
    for i in A:
        for j in range(idx,len(B)):
            if i <B[j]:
                idx = j+1
                answer+=1
                break
                
    return answer