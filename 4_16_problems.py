# -*- coding: utf-8 -*-
"""4/16/problems.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kjrbN5gZF28vO8xlsErGo_OKw_ehYpp5
"""

# 방금그곡
# 음악을 중간에 끊을 경우 원본 음악에 있어도 해당 x
# 재생시간동안 나온 악보를 도출한다.
# 메모리와 비교한다.
# 여러개면 재생된 시간이 제일 긴
# 시간도 같을 경우 먼저 입력된 음악
# 없으면 (None)
def solution(m, musicinfos):
    result = []
    m = list(m)
    for musicinfo in musicinfos:
        start,end,title,note = musicinfo.split(',')
        note = list(note)
    # #처리
        for idx, i in enumerate(note):
            if i == '#':
                note[idx-1]+=i
                note.pop(idx)
        for idx, i in enumerate(m):
            if i == '#':
                m[idx-1]+=i
                m.pop(idx)
        start_hour,start_min = map(int,start.split(':'))
        end_hour,end_min = map(int,end.split(":"))
        start_to_end = (end_hour-start_hour)*60 + (end_min-start_min)
        play_music = note*(start_to_end//len(note))+note[:start_to_end%len(note)]
        for i in range(len(play_music)):
            if i+len(m)>len(play_music):
                break
            elif m == play_music[i:i+len(m)]:
                result.append((start_to_end,title))
    result = sorted(result,key = lambda x : x[0], reverse=True)
    if len(result)==0:
        return "(None)"
    else:
        return result[0][1]

#압축

def solution(msg):
    answer = []
    dic = ['A','B','C','D','E','F','G','H','I','J',
           'K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    idx = 0
    a = 0
    while idx<len(msg):
        find = False
        for i in range(len(msg),-1,-1):
            if find:
                break
            if idx+i>len(msg):
                continue
            now = msg[idx:idx+i]
            
            for index,j in enumerate(dic):
                if now == j:
                    answer.append(index+1)
                    if idx+i+1<=len(msg):
                        dic.append(msg[idx:idx+i+1])
                    find = True
                    idx+=i
                    break
    return answer

#파일명정렬
def solution(files):
    number_list = [str(i) for i in range(10)]
    result = []
    for file in files:
        for idx1 in range(len(file)): 
            if file[idx1] in number_list:
                head_idx = idx1
                break
        for idx2 in range(head_idx,len(file)):
            if file[idx2] not in number_list:
                number_idx = idx2
                break
            if idx2==len(file)-1:
                number_idx = len(file)
        head = file[:head_idx].lower()
        number = file[head_idx:number_idx] 
        number = int(number)
        tail = file[number_idx:]
        result.append([head,number,tail,file])
    result = sorted(result,key = lambda x : (x[0],x[1]))
    answer = []
    for i in result:
        answer.append(i[-1])
    return answer

#오픈채팅방 

from collections import defaultdict
def solution(record):
    dic = defaultdict(list)
    result = []
    for info in record:
        information = info.split()

        if information[0]=="Enter":
            dic[information[1]]=information[-1]
        if information[0]=="Change":
            dic[information[1]]= information[-1]
    for info in record:
        information = info.split()

        if information[0]=="Enter":
            result.append("{}님이 들어왔습니다.".format(dic[information[1]]))
        elif information[0]=="Leave":
            result.append("{}님이 나갔습니다.".format(dic[information[1]]))
    
    
    return result

# 합승 택시 요금
# 플로이드
# start를 기준으로 최소 거리 다 계산 후
# default min 은 따로따로 가는 것

# 중간지점까지 가는 것들을 일일히 node로 계산
# 그 지점에서 각각 도착점까지 가는 것 계산

def solution(n, s, a, b, fares):
    INF = int(100001)*n
    graph = [[INF]*(n+1) for _ in range(n+1)]
    for i in range(1,n+1):
        graph[i][i]=0
    for node_1,node_2,cost in fares:
        graph[node_1][node_2]=cost
        graph[node_2][node_1]=cost
    #Floyd
    for k in range(1,n+1):
        for i in range(1,n+1):
            for j in range(1,n+1):
                graph[i][j] = min(graph[i][j],graph[i][k]+graph[k][j])
    #중간지점별로 계산시작
    min_paid = graph[s][a]+graph[s][b]
    for node in range(1,n+1):
        min_paid = min(min_paid, graph[s][node]+graph[node][a]+graph[node][b])
    answer = min_paid
    return answer